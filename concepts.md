В первую очередь я бы хотел что-бы мой фреймворк соблюдал концепт модульного подхода, что дает нам модульный подход?
  1. Код разбивается на независимые блоки, каждый со своей функциональностью.
  2. Модули скрывают внутреннюю реализацию, предоставляя только API.
При грамотном применении данного подхода мы получаем слабую связанность что позволяет нам переиспользовать наши готовые блоки в различных приложениях. Так же соблюдаются принципы SOLID.
Если же приводить примеры ближе к практике то модульный подход позволит:
  1. Разделить и изолировать логику UI соблюдая при этом паттерны mvc, mvp и mvvm.
  2. Разделить и изолировать бизнес-логику (Например вынести ее в другие модули о которых я напишу ниже)

Второй концепт "Состояние => UI", что это значит? Наш UI привязан к "Состоянию" который представляет собой Данные. "Состояние" влияет на отображение пользовательского интерфейса и взаимодействие с пользователем. Но почему мы называем это "Состоянием"?
Разберем на примере:
  Пример с переменной:
  ```javascript 
  function Counter() {
  let count = 0;
    return (
      <div>
        <p>Счетчик: {count}</p>
        <button onClick={() => count++}>Увеличить</button>
      </div>
    );
  }
  ```
При клике на кнопку значение count увеличивается, но UI не обновляется, потому что React не знает о изменении обычной переменной.
  Пример с состоянием:
  ```javascript 
  function Counter() {
  const [count, setCount] = useState(0);
    return (
      <div>
        <p>Счетчик: {count}</p>
        <button onClick={() => setCount(count + 1)}>Увеличить</button>
      </div>
    );
  }
  ```
При клике на кнопку вызывается setCount, React узнает об изменении состояния и перерендерит компонент.
Исходя из этого мы узнали что основные характеристики состояния:
  1. Изменяемость — состояние может меняться в ответ на действия пользователя или другие события.
  2. Реактивность — изменения состояния вызывают обновление пользовательского интерфейса.
И для реализации "Состояния" в своем фреймворке я использую следующий подход:
  ```javascript
    class ReactiveState<T> {
      private _value: T

      constructor(value: T) {
        this._value = value
      }

      get value() {
        return this._value
      }

      set value(newVal) {
        this._value = newVal
        // Сюда мы в дальнейшем передаем функцию для уведомления о изменениях чтобы наше состояние было реактивным
      }
    }

    function reactive(value: unknown) {
      // Так же мы будем оборачивать новый объект в Proxy для обеспечения глубокой реактивности
      const newState = new Proxy(new ReactiveState(value), mutableHandlers)
      // Подразумевается что функция mutableHandlers будет обрабатывать который операции доступа и изменения объектов
      return newState
    }
  ```
И для определения нашего состояния которое необходимо вывести в UI мы будем использовать данную функцию:
  ```javascript
    const counter = reactive(0)
  ```
